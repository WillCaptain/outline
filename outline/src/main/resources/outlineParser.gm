/*
* this is outline parser for a new dynamic language inferred by GCP method
* huizi 2024
*/
parser grammar OutlineParser;

options {
    tokenVocab = OutlineLexer;
}
//in msll, a root non terminal is required
root
    :  module_statement? import_statement* statement+ export_statement?
    ;
//---------statements----------------
statement
    : comment
    | variable_declarator
    | expression_statement
    | return_statement
//    | module_statement
//    | import_statement
//    | export_statement
//    | classDeclaration
//    | functionDeclaration
//    | expressionStatement
//    | iterationStatement
//    | continueStatement
//    | breakStatement
//    | returnStatement
//    | yieldStatement
//    | withStatement
//    | labelledStatement
//    | switchStatement
//    | throwStatement
//    | tryStatement
//    | debuggerStatement
    ;

//--------statements--------------
module_statement
    : 'module' factor_expression
    ;
import_statement
    : 'import' ('*' | (ID ('as' ID)? (',' ID ('as' ID)? )*)) 'from' (factor_expression | ID) ';'
    ;
export_statement
    : 'export' ID ('as' ID)? ','+ ID ('as' ID)? ';'
    ;
comment
    : SingleLineComment
    | MultiLineComment
    ;
variable_declarator
    : ('let'|'var') {notLineTerminator()} argument '=' expression (',' argument '=' expression)* ';'
    ;
return_statement
    : 'return' expression? ';'
    ;
//---------------type-----------------
declared_outline
    : fix_outline (('|'|'&') fix_outline)*
    ;
fix_outline
    : Number_Type | Int_Type | Float_Type | Double_Type | String_Type | tuple_type | func_type | '?' | ID | literal
    ;
tuple_type
    : '(' declared_outline (','declared_outline)* ')'
    ;
//------------expressions-------------
expression
    : assignment
    ;
assignment
    : conditional_expression (('='|'+='|'-='|'*='|'/=') assignment)?
    ;
conditional_expression
    : if_expression
    | ternary_expression
    ;
if_expression
    : 'if' '(' expression ')' expression ('else' expression)?
    ;
//if_tail
//    : if_expression
//    | expression
//    ;
ternary_expression
    : or_expression ('?' expression ':' conditional_expression)?
    ;
or_expression
  : and_expression ('||' and_expression)*
  ;

and_expression
  : equality_expression ('&&' equality_expression)*
  ;

equality_expression
  : relational_expression (('==' | '!=') relational_expression)*
  ;

relational_expression
  : numeric_expression (('<' | '>' | '<=' | '>=') numeric_expression)*
  ;
numeric_expression
    :term_expression (('+'|'-') term_expression)*
    ;
term_expression
    :unary_expression (('*'|'/'|'%'|'^') unary_expression)*
    ;
unary_expression
    : ('++' | '--' | '-' | '!') factor_expression
    |factor_expression ('++'|'--')?
    ;
factor_expression
    : literal
    | This
    | ID
    | factor_expression '[' expression ']'                           # array_map_accessor
    | factor_expression '.' (ID|INT)                                 # entity_member_accessor
    | factor_expression '(' (expression (','+ expression)*)? ')'     # function_call
    | factor_expression '&' expression                               # poly_expression
    | '(' expression ')'
    ;
literal
    : number
    | STRING
    | entity
    | tuple
    | block
    | array
    | map
    | lambda
    ;
number
    : INT ('.' INT)? | DOUBLE | FLOAT
    ;
expression_statement
    : expression ((',' expression)* ';')?
    ;

block
    : '{' statement*'}'
    ;
array
    : '[' expression (',' expression)* ']'
    ;
map
    : '[' expression ':' expression (',' expression ':' expression)* ']'
    ;
entity
    : '{' property_assignment (',' property_assignment)* ','? '}'
    ;
tuple
    : '(' expression (','expression)* ')'
    ;
property_assignment
    : (('let'|'var') {notLineTerminator()})? argument '=' expression
    ;
lambda
    : references? lambda_args '->' expression
    ;
lambda_args
    : ID
    | function_args'
    ;
function_args'
    : '(' (argument (','+ argument)*)? ')'
    ;
argument
    : ID (':' declared_outline)?
    ;
references
    : Function? '<' reference (','+ reference)* '>'
    ;
reference
    : ID (':' declared_outline)?
    ;

