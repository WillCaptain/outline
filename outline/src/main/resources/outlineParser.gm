/*
* this is outline parser for a new dynamic language inferred by GCP method
* huizi 2024
*/
parser grammar OutlineParser;

options {
    tokenVocab = OutlineLexer;
}
//in msll, a root non terminal is required
root
    :  module_statement? import_statement* statement+ export_statement?
    ;
//---------statements----------------
statement
    : comment
    | variable_declarator
    | assignment
    | empty_statement
    | return_statement
//    | module_statement
//    | import_statement
//    | export_statement
//    | classDeclaration
//    | functionDeclaration
//    | expressionStatement
//    | ifStatement
//    | iterationStatement
//    | continueStatement
//    | breakStatement
//    | returnStatement
//    | yieldStatement
//    | withStatement
//    | labelledStatement
//    | switchStatement
//    | throwStatement
//    | tryStatement
//    | debuggerStatement
    ;

//--------statements--------------
module_statement
    : 'module' factor_expression
    ;
import_statement
    : 'import' ('*' | (ID ('as' ID)? (',' ID ('as' ID)? )*)) 'from' (factor_expression | ID) ';'
    ;
export_statement
    : 'export' ID ('as' ID)? ','+ ID ('as' ID)? ';'
    ;
comment
    : SingleLineComment
    | MultiLineComment
    ;
variable_declarator
    : ('let'|'var') {notLineTerminator()} argument '=' expression (',' argument '=' expression)* ';'
    ;
empty_statement
    : expression ';'?
    ;
return_statement
    : 'return' expression ';'
    ;
//------------expressions-------------
expression
    : numeric_expression
    ;
numeric_expression
    :term_expression (('+'|'-') term_expression)*
    ;
term_expression
    :unary_expression (('*'|'/'|'%'|'^') unary_expression)*
    ;
unary_expression
    : ('++' | '--' | '-') factor_expression
    |factor_expression ('++'|'--')?
    ;
declared_outline
    : Number_Type | Int_Type | Float_Type | Double_Type | String_Type | tuple_type | '?'
    ;
factor_expression
    : literal
    | ID
    | entity
    | tuple
    | block
    | array
    | map
    | lambda
    | factor_expression '[' expression ']'                           # array_map_accessor
    | factor_expression '.' (ID|NUMBER)                              # entity_member_accessor
    | factor_expression '(' (expression (','+ expression)*)? ')'     # function_call
    | '(' expression ')'
    ;
literal
    : NUMBER
    | STRING
    | This
    ;
assignment
    : ID ('='|'+='|'-='|'*='|'/=') expression ';'
    ;
block
    : '{' statement* '}'
    ;
array
    : '[' expression (',' expression)* ']'
    ;
map
    : '[' expression ':' expression (',' expression ':' expression)* ']'
    ;
entity
    : '{' property_assignment (',' property_assignment)* ','? '}'
    ;
tuple
    : '(' expression (','expression)* ')'
    ;
property_assignment
    : (('let'|'var') {notLineTerminator()})? argument '=' expression
    ;
lambda
    : lambda_args '->' (expression|block)
    ;
lambda_args
    : ID
    | function_args'
    ;
function_args'
    : '(' (argument (','+ argument)*)? ')'
    ;
argument
    : ID (':' declared_outline)?
    ;
tuple_type
    : '(' declared_outline (','declared_outline)* ')'
    ;
