/*
* this is outline parser for a new dynamic language inferred by GCP method
* huizi 2024
*/
parser grammar OutlineParser;

options {
    tokenVocab = OutlineLexer;
}
//in msll, a root non terminal is required
root
    :  module_statement? import_statement* statement+ export_statement?
    ;
//---------statements----------------
statement
    : comment
    | variable_declarator
    | expression_statement
    | return_statement
    | outline_declarator
//    | classDeclaration
//    | functionDeclaration
//    | expressionStatement
//    | iterationStatement
//    | continueStatement
//    | breakStatement
//    | yieldStatement
//    | labelledStatement
//    | switchStatement
//    | throwStatement
//    | tryStatement
//    | debuggerStatement
    ;

//--------statements--------------
module_statement
    : 'module' factor_expression
    ;
import_statement
    : 'import' ('*' | (ID ('as' ID)? (',' ID ('as' ID)? )*)) 'from' factor_expression ';'
    ;
export_statement
    : 'export' ID ('as' ID)? ','+ ID ('as' ID)? ';'
    ;
outline_declarator
    : 'outline' Symbol '=' extend_outline (',' Symbol '=' extend_outline)* ';'
    ;
extend_outline
    : declared_outline entity_type?
    ;
comment
    : SingleLineComment
    | MultiLineComment
    ;
variable_declarator
    : ('let'|'var') {notLineTerminator()} assignment' (',' assignment')* ';'
    ;
assignment'
    : argument ('=' expression)?
    | (entity_unpack | tuple_unpack) '=' expression
    ;
return_statement
    : 'return' expression? ';'
    ;
//---------------type-----------------
declared_outline
    : func_type | non_func_type
    ;
non_func_type
    : adt_type | factor_type |symbol_type
    ;
reference_call
    : reference_parameters'
    ;

reference_parameters'
    : '<' declared_outline (',' declared_outline)* '>'
    ;
adt_type
    : (factor_type|literal|symbol_type) (('|'|'&') (factor_type|literal|symbol_type))+
    ;
factor_type
    : (Number_Type | Int_Type | Long_Type | Float_Type | Unit_Type
    | Double_Type | String_Type | tuple_type | THIS | literal_type
    | entity_type | array_type | map_type |  '?' | ID | Symbol
    | '(' declared_outline ')') reference_call?
    ;
literal_type
    : '#' literal
    ;

tuple_type
    : reference_type? '(' ('...'|declared_outline) (',' ('...'|declared_outline))+ ')'
    ;
entity_type
    : reference_type? '{' (argument (','argument)* ','?)? '}'
    ;
symbol_type
    : Symbol (tuple_type | entity_type)
    ;
array_type
    : '[' declared_outline ']'
    ;
map_type
    : '[' declared_outline ':' declared_outline ']'
    ;
func_type
    : reference_type? non_func_type '->' declared_outline
    ;
reference_type
    : Function? '<'argument (','argument)* '>'
    ;
//------------expressions-------------
expression
    : assignment (is_expression | as_expression)?
    ;
is_expression
    : 'is' declared_outline ('as' (ID | symbol_unpack))?
    ;
as_expression
    : 'as' declared_outline
    ;
symbol_unpack
    : Symbol? (entity_unpack | tuple_unpack)
    ;
unpack_fragment'
    :symbol_unpack|Number_Type | Int_Type | Long_Type | Float_Type | Double_Type | String_Type
    ;
tuple_ids'
    : ID|'_'|'...'|unpack_fragment'
    ;
entity_ids'
    : ID (('as' ID)|(':' unpack_fragment'))?
    ;
entity_unpack
    : '{' entity_ids' (',' entity_ids')* '}'
    ;
tuple_unpack
    : '(' tuple_ids' (',' tuple_ids')* ')'
    ;
match_expression
    : 'match' ID '{' match_arms' '}'
    ;
match_arms'
    : match_arm (',' match_arm)* ','?
    ;
match_arm
    : (symbol_unpack | ID | number | STRING | '_') match_if? '->' expression
    ;
match_if
    : 'if' or_expression
    ;
assignment
    : complex_expression (('='|'+='|'-='|'*='|'/=') assignment)?
    ;
complex_expression
    : if_expression
    | match_expression
    | ternary_expression entity?
    ;
if_expression
    : 'if' '(' expression ')' expression ('else' expression)?
    ;
ternary_expression
    : poly_or_option_expression ('?' expression ':' complex_expression)?
    ;
poly_or_option_expression
    : or_expression (('|' | '&' ) or_expression)*
    ;
or_expression
  : and_expression ('||' and_expression)*
  ;

and_expression
  : equality_expression ('&&' equality_expression)*
  ;

equality_expression
  : relational_expression (('==' | '!=') relational_expression)*
  ;

relational_expression
  : numeric_expression (('<' | '>' | '<=' | '>=') numeric_expression)*
  ;
numeric_expression
    :term_expression (('+'|'-') term_expression)*
    ;
term_expression
    :unary_expression (('*'|'/'|'%'|'^') unary_expression)*
    ;
unary_expression
    : ('++' | '--' | '-' | '!') factor_expression
    |factor_expression ('++'|'--')?
    ;
factor_expression
    : literal
    | ID
    | Symbol
    | block
    | with_expression
    | factor_expression '[' expression ']'                                 # array_map_accessor
    | factor_expression '.' (ID|INT)                                       # entity_member_accessor
    | factor_expression '(' (expression (','+ expression)*)? ')'           # function_call
    | factor_expression reference_parameters'                              # reference_call
    //| factor_expression '<' declared_outline (',' declared_outline)* '>' # reference_call
    //| factor_expression '&' expression                                   # poly_expression
    //| '(' expression ')'                                                 # factor
    ;
literal
    : This
    | Base
    | True
    | False
    | number
    | STRING
    | entity
    | tuple
    | array
    | map
    | lambda
    | factor
    ;
factor
    : '(' expression ')'
    ;
number
    : INT ('.' INT)? | DOUBLE | FLOAT
    ;
expression_statement
    : expression ((',' expression)* ';')?
    ;
with_expression
    : 'with' expression ('as' ID)? block
    ;
block
    : '{' statement* '}'
    ;
array
    : '[' (array_enum_items | array_iterate_expression)? ']'
    ;
array_enum_items
    : expression (',' expression)*
    ;
array_iterate_expression
    : array_iterate_range (',' INT ',' lambda ',' lambda)?
    ;
array_iterate_range
    : INT? '...' INT
    ;
map
    : '[' (':' | ( literal ':' expression (',' literal ':' expression)* )) ']'
    ;
entity
    : '{' property_assignment (',' property_assignment)* ','? '}'
    ;
tuple
    : '(' expression (','expression)+ ')'
    ;
property_assignment
    : (('let'|'var') {notLineTerminator()})? argument '=' expression
    ;
lambda
    : reference_type? lambda_args '->' expression ('&&&' lambda)*
    ;
lambda_args
    : ID
    | function_args'
    ;
function_args'
    : '(' (argument (','+ argument)*)? ')'
    ;
argument
    : ID (':' declared_outline)?
    ;


